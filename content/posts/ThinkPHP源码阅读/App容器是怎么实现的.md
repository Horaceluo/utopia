---
title: "App容器时怎么实现的"
date: 2022-01-16T17:18:00+08:00
draft: true
isCJKLanguage: true
categories:
- 源码阅读
tags:
- 源码
- PHP
---

# 前言

从5.0版本开始，ThinkPHP已经开始逐步使用依赖注入了。从那时开始，就可以看到，框架的核心入口类App开始继承一个名为Container的类。到了6.0，又更加完善了这个Container类，实现Psr(PSR-11)的ContainerInterface。那么什么时容器？容器在框架里到底起到什么样的作用？ThinPHP又时怎么样实现容器的？我们来一探究竟。

## 控制反正与依赖注入

通常来说，我们要一个类里面调用另外一个类的方法时，最直接的方式就是，在类里面通过new关键字生成一个类的实例对象，再通过这个对像来调用目标方法。

对于简单的应用而言，直接new可能没有多大的影响。但是对于大型应用而言，这就会使得几十甚至几百、几千个类中形成错综复杂的依赖关系。而且直接在方法里面new一个对象，很可能导致该方法无法进行单元测试。例如，A 类型 的a方法new了一个B类，当执行a方法的单元测试时候，就一定得保证B类是正常的，不然就会导致a方法测试失败。

那要怎么做才能改变这种局面呢？一个比较常见的方法就是“控制反转”，而依赖注入，就是控制反转的一种实现。

### “反转”的关键在于类是如何获得依赖

A类需要B类，如果是A自己去寻找、获取、生成B类，例如直接在类里面new B，这种就是强依赖的关系。如果A需要B类，且这个类并不是自己去new获取的，而是外界通过一定方式将依赖类传输给A的，那么这种依赖关系就“反转”了。原本是A需要控制B的生成，现在不需要了，A只需要使用B就行，无效关系B如何产生的了。

### 依赖的管理者

当对象自己不需要去“new”其他对象的时候，那么对象的依赖关系由谁去处理呢？在ThinkPHP6.0中，App就是这样的一个角色，它可以管理应用中各种的类型实例化，并将这些实例注入到依赖他们的类或者方法中。


## Container

App对象实际上并只是一个容器的角色，它还承担着应用的初始化等很多的功能。我们要了解它的容器功能，更好的方式是看它的父类，Container是怎么实现的。

### Container实现的接口

Container一共实现了4个接口，他们分别是：

- Psr\Container\ContainerInterface Psr的容器管理接口，有get和has两个函数
- ArrayAccess PHP的数组访问接口，这个意味着，App类可以像数组一样访问
- IteratorAggregate PHP的外部迭代器接口，意味着可以使用foreach来循环输出
- Countable PHP的count接口，App对象可以作为count()函数的输入

