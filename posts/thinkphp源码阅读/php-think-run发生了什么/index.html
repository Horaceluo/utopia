<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>TP源码：php think run 发生了什么 | Horace</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu></ul><hr></nav><div class=article-meta><h1><span class=title>TP源码：php think run 发生了什么</span></h1><h2 class=date>2022/01/09</h2></div><main><p>安装好TP6.0之后，根据官方的文档指引，我们可以运行这个命令来启动一个http服务器</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ php think run
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ThinkPHP Development server is started On &lt;http://0.0.0.0:8000/&gt;
</span></span><span style=display:flex><span>You can <span style=color:#0086b3>exit</span> with <span style=color:#d14>`</span>CTRL-C<span style=color:#d14>`</span>
</span></span><span style=display:flex><span>Document root is: /var/www/tp6.0/public
</span></span></code></pre></div><p>启动完成之后，我们就可以通过8000端口来访问我们的服务了。</p><h2 id=think>think</h2><p>在项目的根目录下，有个名为think的文件。这个文件在项目创建的时候就已经生成了。实际上这个文件可以理解为
命令行模式下的"入口文件"。与之类似的，public目录下的index.php文件是http服务的入口。</p><p>think 文件很短小，很简洁。同index.php一样，与6.0之前的版本相比，去除很多常量的设置。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#998;font-style:italic>#!/usr/bin/env php
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>&lt;?</span>php
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>namespace</span> think;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 命令行入口文件
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 加载基础文件
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>require</span> <span style=color:teal>__DIR__</span> <span style=color:#000;font-weight:700>.</span> <span style=color:#d14>&#39;/vendor/autoload.php&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 应用初始化
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>(<span style=color:#000;font-weight:700>new</span> App())<span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>console</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>run</span>();
</span></span></code></pre></div><p>第1行是Shebang，这意味着在执行think的时候，如果think文件有执行权限的话，是不需要加上php命令的，默认会使用php进行执行</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ./think run
</span></span></code></pre></div><p>第2行是载入composer的autoload文件，这样就把require委托给了autoload去处理。我们只需要use相关的命名空间就可以了。</p><p>第3行是初始化了TP的应用类(容器)，然后通过内置的console对象来执行命令行的逻辑。如果是index文件的话，这里就是通过Request对象来处理来http的请求。</p><p>总得来说，think文件有两个作用：</p><ol><li>加载autoload.php，初始化自动引入的功能</li><li>执行命令行的入口函数，即Console对象的run函数</li></ol><h2 id=console>console</h2><p>从代码中也可以看到，命令行实际上是通过Console对象来执行的。Console对象主要是用来管理命令行的各种命令的初始化、注册、运行。</p><h3 id=console的构造函数>console的构造函数</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> __construct(App <span style=color:teal>$app</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>app</span> <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$app</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>initialize</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>definition</span> <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>getDefaultInputDefinition</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#998;font-style:italic>//加载指令
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>loadCommands</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>start</span>();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>构造函数主要完成了这几件事情</p><ul><li>初始化（确认APP容器已初始化、构造Request对象[模拟http环境]）</li><li>设置初始化的默认选项(&ndash;help,&ndash;version等)</li><li>加载命令(默认的命令：help、make等，配置文件里的自定义命令)</li><li>执行应用启动的回调</li></ul><h2 id=run>run</h2><p>console对象初始化完成之后，就可以运行run方法了。run方法的主要完成两件事情</p><ol><li>识别需要运行的命名</li><li>构造Input和Output对象</li></ol><p>完成这两件事情之后，把Input和Output对象注入到命令绑定的Command类中，最后通过Command类的run方法执行真正的命令行业务逻辑。</p><p>因此，对于<code>php think run</code> 这个命令来说。最后的启动http服务的逻辑实际上是在&rsquo;run&rsquo;这个命令绑定的Command类的run方法里。</p><h2 id=runserver>RunServer</h2><p>think\console\command\RunServer 这个类就是run命令绑定的命令行类。这个类只有两个方法。</p><ul><li>configure()</li><li>execute(Input $input, Output $output)</li></ul><p>configure() 方法是为该命令注册命令的名称，选项，参数，说明等基础信息。这个方法会在Command对象构造器里执行。执行之后，RunServer就可以通过getName(),getDefinition()等方法获得这些配置信息。</p><p>execute() 方法是业务逻辑执行的方法。前面提到过，执行业务逻辑的是通过Command的run()方法执行的。到这里，怎么就变成了execute()方法了呢？</p><p>实际上，RunServer是继承于Command抽象类，run()是Command的方法，最后在run()方法里面会调用execute()方法。</p><p>RunServer的execute方法也很简单</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> <span style=color:#900;font-weight:700>execute</span>(Input <span style=color:teal>$input</span>, Output <span style=color:teal>$output</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:teal>$host</span> <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$input</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>getOption</span>(<span style=color:#d14>&#39;host&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:teal>$port</span> <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$input</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>getOption</span>(<span style=color:#d14>&#39;port&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:teal>$root</span> <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$input</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>getOption</span>(<span style=color:#d14>&#39;root&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> (<span style=color:#000;font-weight:700>empty</span>(<span style=color:teal>$root</span>)) {
</span></span><span style=display:flex><span>            <span style=color:teal>$root</span> <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>app</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>getRootPath</span>() <span style=color:#000;font-weight:700>.</span> <span style=color:#d14>&#39;public&#39;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:teal>$command</span> <span style=color:#000;font-weight:700>=</span> sprintf(
</span></span><span style=display:flex><span>            <span style=color:#d14>&#39;php -S %s:%d -t %s %s&#39;</span>,
</span></span><span style=display:flex><span>            <span style=color:teal>$host</span>,
</span></span><span style=display:flex><span>            <span style=color:teal>$port</span>,
</span></span><span style=display:flex><span>            escapeshellarg(<span style=color:teal>$root</span>),
</span></span><span style=display:flex><span>            escapeshellarg(<span style=color:teal>$root</span> <span style=color:#000;font-weight:700>.</span> DIRECTORY_SEPARATOR <span style=color:#000;font-weight:700>.</span> <span style=color:#d14>&#39;router.php&#39;</span>)
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:teal>$output</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>writeln</span>(sprintf(<span style=color:#d14>&#39;ThinkPHP Development server is started On &lt;http://%s:%s/&gt;&#39;</span>, <span style=color:teal>$host</span>, <span style=color:teal>$port</span>));
</span></span><span style=display:flex><span>        <span style=color:teal>$output</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>writeln</span>(sprintf(<span style=color:#d14>&#39;You can exit with &lt;info&gt;`CTRL-C`&lt;/info&gt;&#39;</span>));
</span></span><span style=display:flex><span>        <span style=color:teal>$output</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>writeln</span>(sprintf(<span style=color:#d14>&#39;Document root is: %s&#39;</span>, <span style=color:teal>$root</span>));
</span></span><span style=display:flex><span>        passthru(<span style=color:teal>$command</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>不难看出，实际上<code>php think run</code>启动的http服务器，实际上是php自带的<a href=https://www.php.net/manual/en/features.commandline.webserver.php>http服务器</a>。所以我们如果在直接启动php自带的服务器其实也可以达到同样的效果</p><h2 id=总结>总结</h2><p>从最后的结果来看，似乎<code>php think run</code>这个命令似乎没有多大存在的必要。于本人而言，实际上<code>php think run</code>要比<code>php -S 127.0.0.1:8080</code> 这样更容易接受一点。通过think执行可以省略一些基本参数，启动过程更为顺畅和简洁。</p><p>对于启动一个http服务器而言，Console这个类的作用实际上并不是很大。它更大意义是在其他命令上。例如队列、定时、单元测试等需要依赖TP框架的命令而言，它能帮助开发者省去手动加载框架的麻烦，也可以屏蔽一些命令行运行和http服务运行的差异。使得我们开发命令行应用也可以像开发http应用一样使用框架的特性，实现代码服用，提高开发效率。</p></main><footer></footer></body></html>