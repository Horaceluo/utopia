<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>TP源码：App容器时怎么实现的 | Horace</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu></ul><hr></nav><div class=article-meta><h1><span class=title>TP源码：App容器时怎么实现的</span></h1><h2 class=date>2022/01/16</h2></div><main><h1 id=前言>前言</h1><p>从5.0版本开始，ThinkPHP已经开始逐步使用依赖注入了。从那时开始，就可以看到，框架的核心入口类App开始继承一个名为Container的类。到了6.0，又更加完善了这个Container类，实现Psr(PSR-11)的ContainerInterface。那么什么时容器？容器在框架里到底起到什么样的作用？ThinPHP又时怎么样实现容器的？我们来一探究竟。</p><h2 id=控制反正与依赖注入>控制反正与依赖注入</h2><p>通常来说，我们要一个类里面调用另外一个类的方法时，最直接的方式就是，在类里面通过new关键字生成一个类的实例对象，再通过这个对像来调用目标方法。</p><p>对于简单的应用而言，直接new可能没有多大的影响。但是对于大型应用而言，这就会使得几十甚至几百、几千个类中形成错综复杂的依赖关系。而且直接在方法里面new一个对象，很可能导致该方法无法进行单元测试。例如，A 类型 的a方法new了一个B类，当执行a方法的单元测试时候，就一定得保证B类是正常的，不然就会导致a方法测试失败。</p><p>那要怎么做才能改变这种局面呢？一个比较常见的方法就是“控制反转”，而依赖注入，就是控制反转的一种实现。</p><h3 id=反转的关键在于类是如何获得依赖>“反转”的关键在于类是如何获得依赖</h3><p>A类需要B类，如果是A自己去寻找、获取、生成B类，例如直接在类里面new B，这种就是强依赖的关系。如果A需要B类，且这个类并不是自己去new获取的，而是外界通过一定方式将依赖类传输给A的，那么这种依赖关系就“反转”了。原本是A需要控制B的生成，现在不需要了，A只需要使用B就行，无效关系B如何产生的了。</p><h3 id=依赖的管理者>依赖的管理者</h3><p>当对象自己不需要去“new”其他对象的时候，那么对象的依赖关系由谁去处理呢？在ThinkPHP6.0中，App就是这样的一个角色，它可以管理应用中各种的类型实例化，并将这些实例注入到依赖他们的类或者方法中。</p><h2 id=container>Container</h2><p>App对象实际上并只是一个容器的角色，它还承担着应用的初始化等很多的功能。我们要了解它的容器功能，更好的方式是看它的父类，Container是怎么实现的。</p><h3 id=container实现的接口>Container实现的接口</h3><p>Container一共实现了4个接口，他们分别是：</p><ul><li>Psr\Container\ContainerInterface Psr的容器管理接口，有get和has两个函数</li><li>ArrayAccess PHP的数组访问接口，这个意味着，App类可以像数组一样访问</li><li>IteratorAggregate PHP的外部迭代器接口，意味着可以使用foreach来循环输出</li><li>Countable PHP的count接口，App对象可以作为count()函数的输入</li></ul><p>从Container实现的接口来看，Container很重要的一个功能是实例的获取、访问。ThinkPHP的Container也提供很多的方式(get、数组访问)来获取容器里的实例。</p><h3 id=container实例的来源>Container实例的来源</h3><p>Container的实例来源以前几个</p><ul><li>bind 方法，可以将实例，闭包绑定到容器里</li><li>instance 方法，可以将类实例绑定到容器里</li><li>make 方法，创建实例并返回实例，创建之后也会将实例绑定到容器</li></ul><p>bind和instance方法比较类似，实际上他们绑定的对象和方式是有区别的。bind方法可以将实例、闭包绑定到容器。而instance方法只是把类实例绑定到容器。所以适用范围上，bind是大于instance方法的。在bind的实现里，如果绑定的是个对象，其实就是调用instance方法来进行绑定。</p><h4 id=bind-方法>bind 方法</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> <span style=color:#900;font-weight:700>bind</span>(<span style=color:teal>$abstract</span>, <span style=color:teal>$concrete</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>null</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> (is_array(<span style=color:teal>$abstract</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>foreach</span> (<span style=color:teal>$abstract</span> <span style=color:#000;font-weight:700>as</span> <span style=color:teal>$key</span> <span style=color:#000;font-weight:700>=&gt;</span> <span style=color:teal>$val</span>) {
</span></span><span style=display:flex><span>            <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>bind</span>(<span style=color:teal>$key</span>, <span style=color:teal>$val</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#000;font-weight:700>elseif</span> (<span style=color:teal>$concrete</span> instanceof Closure) {
</span></span><span style=display:flex><span>        <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>bind</span>[<span style=color:teal>$abstract</span>] <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$concrete</span>;
</span></span><span style=display:flex><span>    } <span style=color:#000;font-weight:700>elseif</span> (is_object(<span style=color:teal>$concrete</span>)) {
</span></span><span style=display:flex><span>        <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>instance</span>(<span style=color:teal>$abstract</span>, <span style=color:teal>$concrete</span>);
</span></span><span style=display:flex><span>    } <span style=color:#000;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:teal>$abstract</span> <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>getAlias</span>(<span style=color:teal>$abstract</span>);
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> (<span style=color:teal>$abstract</span> <span style=color:#000;font-weight:700>!=</span> <span style=color:teal>$concrete</span>) {
</span></span><span style=display:flex><span>            <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>bind</span>[<span style=color:teal>$abstract</span>] <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$concrete</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> <span style=color:teal>$this</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=instance-方法>instance 方法</h4><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> <span style=color:#900;font-weight:700>instance</span>(string <span style=color:teal>$abstract</span>, <span style=color:teal>$instance</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:teal>$abstract</span> <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>getAlias</span>(<span style=color:teal>$abstract</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:teal>$this</span><span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>instances</span>[<span style=color:teal>$abstract</span>] <span style=color:#000;font-weight:700>=</span> <span style=color:teal>$instance</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> <span style=color:teal>$this</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bind和instance>$bind和$instance</h3><p>$bind 和 $instance 是容器两个比较重要的属性。$bind是用于存在绑定的“标识”，例如绑定的类名、闭包。$instance则是存储类的实例。</p><p>App类里默认绑定的类</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#d14>/**
</span></span></span><span style=display:flex><span><span style=color:#d14>     * 容器绑定标识
</span></span></span><span style=display:flex><span><span style=color:#d14>     * @var array
</span></span></span><span style=display:flex><span><span style=color:#d14>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>protected</span> <span style=color:teal>$bind</span> <span style=color:#000;font-weight:700>=</span> [
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;app&#39;</span>                     <span style=color:#000;font-weight:700>=&gt;</span> App<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;cache&#39;</span>                   <span style=color:#000;font-weight:700>=&gt;</span> Cache<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;config&#39;</span>                  <span style=color:#000;font-weight:700>=&gt;</span> Config<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;console&#39;</span>                 <span style=color:#000;font-weight:700>=&gt;</span> Console<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;cookie&#39;</span>                  <span style=color:#000;font-weight:700>=&gt;</span> Cookie<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;db&#39;</span>                      <span style=color:#000;font-weight:700>=&gt;</span> Db<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;env&#39;</span>                     <span style=color:#000;font-weight:700>=&gt;</span> Env<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;event&#39;</span>                   <span style=color:#000;font-weight:700>=&gt;</span> Event<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;http&#39;</span>                    <span style=color:#000;font-weight:700>=&gt;</span> Http<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;lang&#39;</span>                    <span style=color:#000;font-weight:700>=&gt;</span> Lang<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;log&#39;</span>                     <span style=color:#000;font-weight:700>=&gt;</span> Log<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;middleware&#39;</span>              <span style=color:#000;font-weight:700>=&gt;</span> Middleware<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;request&#39;</span>                 <span style=color:#000;font-weight:700>=&gt;</span> Request<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;response&#39;</span>                <span style=color:#000;font-weight:700>=&gt;</span> Response<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;route&#39;</span>                   <span style=color:#000;font-weight:700>=&gt;</span> Route<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;session&#39;</span>                 <span style=color:#000;font-weight:700>=&gt;</span> Session<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;validate&#39;</span>                <span style=color:#000;font-weight:700>=&gt;</span> Validate<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;view&#39;</span>                    <span style=color:#000;font-weight:700>=&gt;</span> View<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;filesystem&#39;</span>              <span style=color:#000;font-weight:700>=&gt;</span> Filesystem<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;think\DbManager&#39;</span>         <span style=color:#000;font-weight:700>=&gt;</span> Db<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;think\LogManager&#39;</span>        <span style=color:#000;font-weight:700>=&gt;</span> Log<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>        <span style=color:#d14>&#39;think\CacheManager&#39;</span>      <span style=color:#000;font-weight:700>=&gt;</span> Cache<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#998;font-style:italic>// 接口依赖注入
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        <span style=color:#d14>&#39;Psr\Log\LoggerInterface&#39;</span> <span style=color:#000;font-weight:700>=&gt;</span> Log<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>,
</span></span><span style=display:flex><span>    ];
</span></span></code></pre></div><p>$bind相当于一个占位符，先把某些标识和类名绑定起来，但是不进行实例化操作。等通过标识从容器里访问类的时候就取出类名，并实例化。实例化之后，如果围显示指定，就会将实例存储到$instance里。</p><h3 id=依赖注入>依赖注入</h3><p>假设有以下两个类，Class A, Class B，其中Class B通过构造器，注入Class A。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>A</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> <span style=color:#900;font-weight:700>a</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>Class</span> <span style=color:#458;font-weight:700>B</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> __construct(A <span style=color:teal>$a</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果是手动实例化，需要先将A类实例化，再把A的实例作为B的构造器参数来实例化B。过程如下面代码所示：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:teal>$classA</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>new</span> A();
</span></span><span style=display:flex><span><span style=color:teal>$classB</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>new</span> B(<span style=color:teal>$classA</span>);
</span></span></code></pre></div><p>这样实际上还是需要人花比较多精力去逐个实例化和逐个注入。但是如果使用容器进行实例化就不需要这样操作了。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:teal>$classB</span> <span style=color:#000;font-weight:700>=</span> app()<span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>make</span>(B<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>);
</span></span></code></pre></div><p>通过容器提供的make方法，可以省略掉手动实例化的步骤，让容器取代人去管理类的依赖关系。这样，即便B类的构造器增加其他类的依赖，在实例化的地方依旧不需要修改代码。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>A</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>C</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>Class</span> <span style=color:#458;font-weight:700>B</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> <span style=color:#900;font-weight:700>__cunstruct</span>(A <span style=color:teal>$a</span>, C <span style=color:teal>$c</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 实例化B
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:teal>$classB</span> <span style=color:#000;font-weight:700>=</span> app()<span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>make</span>(B<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>);
</span></span></code></pre></div><p>B类增加了C类的依赖, 在实例化的地方，可以保持不变。</p><h4 id=make>make</h4><p>对于容器来说，它是怎么知道实例化的类需要哪些参数的？&ndash;反射。</p><p>正是通过反射，在实例化之前，make方法会先解析类的构造函数，逐一分析构造函数的参数。通过获取参数的类型提示，容器就可以知道参数绑定的是哪个类。</p><p>例如上面的例子，通过B类的反射，容器就能知道B类型的构造函数第一个参数是A类的实例，然后就会去寻找容器里是否已有A类的实例。如果没有，重新获取A类的反射，由于A类的构造器没有参数，所以容器就能将A类实例化并把A的实例化传入B的构造器里。如果A类型还有参数，容器就会继续“反射-实例化”的过程，直到所有的参数都满足实例化要求。</p><p>也是由于有这个不断递归的实例化过程，如果A类，B类相互依赖了，就会造成循环依赖，导致实例化错误。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#000;font-weight:700>Class</span> <span style=color:#458;font-weight:700>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> __construct(B <span style=color:teal>$b</span>) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>B</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> __construct(A <span style=color:teal>$a</span>) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// A和B循环依赖，无法实例化B
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:teal>$classB</span> <span style=color:#000;font-weight:700>=</span> app()<span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>make</span>(B<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>);
</span></span></code></pre></div><h4 id=invoke>invoke</h4><p>除了通过make方法实现构造函数注入之外，ThinkPHP还支持类方法的注入。例如下面的例子，通过invoke方法来向Class B中b方法注入Class A的实例。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#000;font-weight:700>Class</span> <span style=color:#458;font-weight:700>A</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>B</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>function</span> <span style=color:#900;font-weight:700>b</span>(A <span style=color:teal>$a</span>) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app()<span style=color:#000;font-weight:700>-&gt;</span><span style=color:teal>invoke</span>([B<span style=color:#000;font-weight:700>::</span><span style=color:teal>class</span>, <span style=color:#d14>&#39;b&#39;</span>]);
</span></span></code></pre></div><p>通过invoke来调用类方法，可以跟实例化一样省去手动实例化并传入参数的过程。</p><h2 id=总结>总结</h2><p>ThinkPHP容器实现的方法支撑是控制反转，通过依赖注入来实现控制反转。而容器就是依赖注入的技术实体，它通过配置“绑定”的方式可以收集、管理各个类的实例。再调用的过程中，通过反射，可以在构造函数、类方法、函数的参数中自动注入依赖。</p><h3 id=不足>不足</h3><p>相比于Java 可以使用注解来进行注入，PHP这种需要使用make\invoke这种特定调用方法才能实现的注入，稍微显得有些蹩脚。</p></main><footer></footer></body></html>