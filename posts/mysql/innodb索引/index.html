<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Innodb索引 | Horace</title><link rel=stylesheet href=/utopia/css/style.css><link rel=stylesheet href=/utopia/css/fonts.css></head><body><nav><ul class=menu></ul><hr></nav><div class=article-meta><h1><span class=title>Innodb索引</span></h1><h2 class=date>2022/01/25</h2></div><main><h1 id=前言>前言</h1><p>MySQL Innodb引擎，无论是聚簇索引，还是二级索引，都是使用B+树来存储数据。B+树有以下特点：</p><ul><li>非叶子节点不存储数据</li><li>叶子节点使用链表连接起来</li></ul><h2 id=聚簇索引和二级索引>聚簇索引和二级索引</h2><p>从物理存储层面上来看，Innodb的索引可分为聚簇索引和二级索引。聚簇索引的非叶子节点存储的是数据主键信息，叶子节点存储了数据的信息。二级索引的非叶子节点存储的是索引信息，叶子节点存储了数据的主键信息。</p><p>从二级索引的与聚簇索引的却别也可以看出，二级索引之所以叫二级索引的原因是：二级索引不存储全部数据信息，而是存储数据的主键，这样在使用二级索引进行查询的时候，可能还需要根据查询到主键去查询数据&ndash;也就是通常说的“回表”操作。</p><h2 id=复合索引>复合索引</h2><p>MySQL一个索引可以包含多个列(最多16列)。索引使用最左匹配原则。假如有以下数据表：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000;font-weight:700>CREATE</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>TABLE</span><span style=color:#bbb> </span>test<span style=color:#bbb> </span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>id<span style=color:#bbb>         </span><span style=color:#0086b3>INT</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>NOT</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>NULL</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>col1<span style=color:#bbb>  </span><span style=color:#0086b3>CHAR</span>(<span style=color:#099>30</span>)<span style=color:#bbb> </span><span style=color:#000;font-weight:700>NOT</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>NULL</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>col2<span style=color:#bbb> </span><span style=color:#0086b3>CHAR</span>(<span style=color:#099>30</span>)<span style=color:#bbb> </span><span style=color:#000;font-weight:700>NOT</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>NULL</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>PRIMARY</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>KEY</span><span style=color:#bbb> </span>(id),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#000;font-weight:700>INDEX</span><span style=color:#bbb> </span>col_index<span style=color:#bbb> </span>(col1,col2)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>col_index索引使用了col1和col2两个列。对于包含了col1，col2的查询，都可以使用索引col_index来优化查询。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>*</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>FROM</span><span style=color:#bbb> </span>test<span style=color:#bbb> </span><span style=color:#000;font-weight:700>where</span><span style=color:#bbb> </span>col1<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#39;A&#39;</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>AND</span><span style=color:#bbb> </span>col2<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#39;B&#39;</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#000;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>*</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>FROM</span><span style=color:#bbb> </span>test<span style=color:#bbb> </span><span style=color:#000;font-weight:700>where</span><span style=color:#bbb> </span>col1<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#39;A&#39;</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><p>上面都可以使用上索引。但是对于下面这个语句，由于不符合最左匹配原则，所以是不会用上索引的。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000;font-weight:700>#</span><span style=color:#bbb> </span><span style=color:#a61717;background-color:#e3d2d2>不会用上索引的语句</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#000;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>*</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>FROM</span><span style=color:#bbb> </span>test<span style=color:#bbb> </span><span style=color:#000;font-weight:700>where</span><span style=color:#bbb> </span>col2<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#39;A&#39;</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=覆盖索引>覆盖索引</h3><p>还是上面的test表，如果增加一个col3字段，如果我们使用以下语句查询</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>*</span><span style=color:#bbb> </span><span style=color:#000;font-weight:700>FROM</span><span style=color:#bbb> </span>test<span style=color:#bbb> </span><span style=color:#000;font-weight:700>where</span><span style=color:#bbb> </span>col1<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#39;A&#39;</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL会使用col1_index字段进行查询。由于是二级索引，所以在查询出col1=&lsquo;A&rsquo;的数据的主键信息之后。还需根据主键在test表获取到col3的数据。</p><p>但是如果把查询语句改为下面这样子：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000;font-weight:700>SELECT</span><span style=color:#bbb> </span>col1,col2<span style=color:#bbb> </span><span style=color:#000;font-weight:700>FROM</span><span style=color:#bbb> </span>test<span style=color:#bbb> </span><span style=color:#000;font-weight:700>where</span><span style=color:#bbb> </span>col1<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#39;A&#39;</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><p>由于col1,col2是复合索引col_index的数据。所以，在匹配到二级索引的数据之后，实际上就可以返回查询结果了。无需再根据主键去查询数据。可以省掉回表的消耗。</p><p>那么在建索引的时候，就需要考虑查询的场景，使得复合索引尽量覆盖查询条件、查询内容。使得索引得效果更佳明显。</p></main><footer></footer></body></html>