<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Horace</title><link>https://example.com/posts/</link><description>Recent content in Posts on Horace</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 25 Jan 2022 14:26:05 +0800</lastBuildDate><atom:link href="https://example.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Innodb索引</title><link>https://example.com/posts/mysql/innodb%E7%B4%A2%E5%BC%95/</link><pubDate>Tue, 25 Jan 2022 14:26:05 +0800</pubDate><guid>https://example.com/posts/mysql/innodb%E7%B4%A2%E5%BC%95/</guid><description>前言 MySQL Innodb引擎，无论是聚簇索引，还是二级索引，都是使用B+树来存储数据。B+树有以下特点：
非叶子节点不存储数据 叶子节点使用链表连接起来 聚簇索引和二级索引 从物理存储层面上来看，Innodb的索引可分为聚簇索引和二级索引。聚簇索引的非叶子节点存储的是数据主键信息，叶子节点存储了数据的信息。二级索引的非叶子节点存储的是索引信息，叶子节点存储了数据的主键信息。
从二级索引的与聚簇索引的却别也可以看出，二级索引之所以叫二级索引的原因是：二级索引不存储全部数据信息，而是存储数据的主键，这样在使用二级索引进行查询的时候，可能还需要根据查询到主键去查询数据&amp;ndash;也就是通常说的“回表”操作。
复合索引 MySQL一个索引可以包含多个列(最多16列)。索引使用最左匹配原则。假如有以下数据表：
CREATETABLEtest(idINTNOTNULL,col1CHAR(30)NOTNULL,col2CHAR(30)NOTNULL,PRIMARYKEY(id),INDEXcol_index(col1,col2));col_index索引使用了col1和col2两个列。对于包含了col1，col2的查询，都可以使用索引col_index来优化查询。
SELECT*FROMtestwherecol1=&amp;#39;A&amp;#39;ANDcol2=&amp;#39;B&amp;#39;;SELECT*FROMtestwherecol1=&amp;#39;A&amp;#39;;上面都可以使用上索引。但是对于下面这个语句，由于不符合最左匹配原则，所以是不会用上索引的。
#不会用上索引的语句SELECT*FROMtestwherecol2=&amp;#39;A&amp;#39;;覆盖索引 还是上面的test表，如果增加一个col3字段，如果我们使用以下语句查询
SELECT*FROMtestwherecol1=&amp;#39;A&amp;#39;;MySQL会使用col1_index字段进行查询。由于是二级索引，所以在查询出col1=&amp;lsquo;A&amp;rsquo;的数据的主键信息之后。还需根据主键在test表获取到col3的数据。
但是如果把查询语句改为下面这样子：
SELECTcol1,col2FROMtestwherecol1=&amp;#39;A&amp;#39;;由于col1,col2是复合索引col_index的数据。所以，在匹配到二级索引的数据之后，实际上就可以返回查询结果了。无需再根据主键去查询数据。可以省掉回表的消耗。
那么在建索引的时候，就需要考虑查询的场景，使得复合索引尽量覆盖查询条件、查询内容。使得索引得效果更佳明显。</description></item><item><title>PHP Composer自动加载解析</title><link>https://example.com/posts/php-composer%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E8%A7%A3%E6%9E%90/</link><pubDate>Thu, 20 Jan 2022 09:42:00 +0800</pubDate><guid>https://example.com/posts/php-composer%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E8%A7%A3%E6%9E%90/</guid><description>前言 composer在各个项目中已经有了广泛的使用。有了composer的加持，PHP项目的包管理变得非常简单。 通过composer，可以很</description></item><item><title>TP源码：App容器时怎么实现的</title><link>https://example.com/posts/thinkphp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/app%E5%AE%B9%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</link><pubDate>Sun, 16 Jan 2022 17:18:00 +0800</pubDate><guid>https://example.com/posts/thinkphp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/app%E5%AE%B9%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</guid><description>前言 从5.0版本开始，ThinkPHP已经开始逐步使用依赖注入了。从那时开始，就可以看到，框架的核心入口类App开始继承一个名为Contai</description></item><item><title>TP源码：php think run 发生了什么</title><link>https://example.com/posts/thinkphp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/php-think-run%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</link><pubDate>Sun, 09 Jan 2022 14:26:05 +0800</pubDate><guid>https://example.com/posts/thinkphp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/php-think-run%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</guid><description>安装好TP6.0之后，根据官方的文档指引，我们可以运行这个命令来启动一个http服务器 $ php think run ThinkPHP Development server is started On &amp;lt;http://0.0.0.0:8000/&amp;gt; You can exit with `CTRL-C` Document root is: /var/www/tp6.0/public 启动完成之后，</description></item></channel></rss>